{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/sirabdisalam/journalite-article-page/src/services/reflectionService.ts"],"sourcesContent":["import {\n    doc,\n    setDoc,\n    getDoc,\n    query,\n    collection,\n    where,\n    getDocs,\n    orderBy,\n    limit,\n    serverTimestamp,\n    Timestamp,\n    deleteDoc,\n    updateDoc\n} from 'firebase/firestore';\nimport { db, auth } from '../firebase/clientApp';\n\nexport interface ReflectionPrompt {\n    id: string;\n    text: string;\n    type: 'emotion' | 'choice' | 'note' | 'custom';\n    triggerPosition?: 'paragraph' | 'percentage'; // Where to trigger the prompt\n    isDefault: boolean;\n}\n\nexport interface ReflectionResponse {\n    id: string;\n    userId: string;\n    articleId: string;\n    promptId: string;\n    promptText: string;\n    response: string;\n    position: number; // Paragraph index or percentage where prompt appeared\n    createdAt: Timestamp;\n    isPrivate: boolean;\n}\n\nexport interface ReflectionJournalEntry {\n    userId: string;\n    articleId: string;\n    articleTitle: string;\n    articleSlug: string;\n    responses: ReflectionResponse[];\n    createdAt: Timestamp;\n    updatedAt: Timestamp;\n}\n\n// Default reflection prompts\nexport const DEFAULT_REFLECTION_PROMPTS: ReflectionPrompt[] = [\n    {\n        id: 'emotion-1',\n        text: 'How does this make you feel?',\n        type: 'emotion',\n        triggerPosition: 'paragraph',\n        isDefault: true\n    },\n    {\n        id: 'choice-1',\n        text: 'Would you have made the same choice?',\n        type: 'choice',\n        triggerPosition: 'paragraph',\n        isDefault: true\n    },\n    {\n        id: 'note-1',\n        text: 'Write your own note to the author.',\n        type: 'note',\n        triggerPosition: 'paragraph',\n        isDefault: true\n    },\n    {\n        id: 'custom-1',\n        text: 'What questions does this raise for you?',\n        type: 'custom',\n        triggerPosition: 'paragraph',\n        isDefault: true\n    },\n    {\n        id: 'custom-2',\n        text: 'How does this relate to your own experience?',\n        type: 'custom',\n        triggerPosition: 'paragraph',\n        isDefault: true\n    }\n];\n\n// Save reflection response to Firestore and local storage\nexport async function saveReflectionResponse(\n    articleId: string,\n    promptId: string,\n    promptText: string,\n    response: string,\n    position: number,\n    isPrivate: boolean = true\n): Promise<void> {\n    console.log('saveReflectionResponse called with:', {\n        articleId,\n        promptId,\n        promptText,\n        response,\n        position,\n        isPrivate\n    });\n\n    const user = auth.currentUser;\n    console.log('Current user:', user ? user.uid : 'Not authenticated');\n\n    if (!user) {\n        // Save to local storage if user is not authenticated\n        console.log('User not authenticated, saving to local storage');\n        saveReflectionToLocalStorage(articleId, promptId, promptText, response, position, isPrivate);\n        return;\n    }\n\n    const responseId = `${user.uid}_${articleId}_${promptId}_${Date.now()}`;\n    const reflectionDoc = doc(db, 'reflectionResponses', responseId);\n\n    const reflectionResponse: ReflectionResponse = {\n        id: responseId,\n        userId: user.uid,\n        articleId,\n        promptId,\n        promptText,\n        response,\n        position,\n        createdAt: serverTimestamp() as Timestamp,\n        isPrivate\n    };\n\n    try {\n        console.log('Attempting to save to Firestore with ID:', responseId);\n        await setDoc(reflectionDoc, reflectionResponse);\n        console.log('Successfully saved to Firestore');\n\n        // Also save a backup to local storage\n        saveReflectionToLocalStorage(articleId, promptId, promptText, response, position, isPrivate);\n    } catch (error) {\n        console.error('Error saving reflection response:', error);\n        // Fallback to local storage\n        saveReflectionToLocalStorage(articleId, promptId, promptText, response, position, isPrivate);\n    }\n}\n\n// Save to local storage for offline functionality\nfunction saveReflectionToLocalStorage(\n    articleId: string,\n    promptId: string,\n    promptText: string,\n    response: string,\n    position: number,\n    isPrivate: boolean\n): void {\n    try {\n        const storageKey = `reflection_${articleId}`;\n        console.log('Saving to local storage with key:', storageKey);\n\n        const existingData = localStorage.getItem(storageKey);\n        const reflections = existingData ? JSON.parse(existingData) : [];\n        console.log('Existing reflections:', reflections.length);\n\n        const newReflection = {\n            id: `local_${Date.now()}`,\n            promptId,\n            promptText,\n            response,\n            position,\n            createdAt: new Date().toISOString(),\n            isPrivate\n        };\n\n        reflections.push(newReflection);\n        localStorage.setItem(storageKey, JSON.stringify(reflections));\n        console.log('Successfully saved to local storage. Total reflections:', reflections.length);\n    } catch (error) {\n        console.error('Error saving reflection to local storage:', error);\n    }\n}\n\n// Get reflection responses for an article\nexport async function getReflectionResponses(articleId: string): Promise<ReflectionResponse[]> {\n    const user = auth.currentUser;\n\n    // Start with local storage data\n    const localReflections = getReflectionsFromLocalStorage(articleId);\n\n    if (!user) {\n        return localReflections;\n    }\n\n    try {\n        const reflectionRef = collection(db, 'reflectionResponses');\n        const q = query(\n            reflectionRef,\n            where('userId', '==', user.uid),\n            where('articleId', '==', articleId),\n            orderBy('createdAt', 'asc')\n        );\n\n        const querySnapshot = await getDocs(q);\n        const firestoreReflections = querySnapshot.docs.map(doc => ({\n            ...doc.data(),\n            createdAt: doc.data().createdAt\n        })) as ReflectionResponse[];\n\n        // Merge local and Firestore data, removing duplicates\n        const allReflections = [...firestoreReflections, ...localReflections];\n        const uniqueReflections = allReflections.filter((reflection, index, self) =>\n            index === self.findIndex(r => r.promptId === reflection.promptId && r.position === reflection.position)\n        );\n\n        return uniqueReflections.sort((a, b) => a.position - b.position);\n    } catch (error) {\n        console.error('Error fetching reflection responses:', error);\n        return localReflections;\n    }\n}\n\n// Get reflections from local storage\nfunction getReflectionsFromLocalStorage(articleId: string): ReflectionResponse[] {\n    try {\n        const storageKey = `reflection_${articleId}`;\n        const data = localStorage.getItem(storageKey);\n        if (!data) return [];\n\n        const reflections = JSON.parse(data);\n        return reflections.map((reflection: any) => ({\n            ...reflection,\n            userId: 'local',\n            articleId,\n            createdAt: new Date(reflection.createdAt) as any\n        }));\n    } catch (error) {\n        console.error('Error reading reflections from local storage:', error);\n        return [];\n    }\n}\n\n// Get a random reflection prompt - optimized for speed\nexport function getRandomReflectionPrompt(): ReflectionPrompt {\n    const randomIndex = Math.floor(Math.random() * DEFAULT_REFLECTION_PROMPTS.length);\n    return DEFAULT_REFLECTION_PROMPTS[randomIndex];\n}\n\n// Get a specific prompt by index for testing (faster than random)\nexport function getPromptByIndex(index: number): ReflectionPrompt {\n    return DEFAULT_REFLECTION_PROMPTS[index % DEFAULT_REFLECTION_PROMPTS.length];\n}\n\n// Create a reflection journal entry\nexport async function createReflectionJournal(\n    articleId: string,\n    articleTitle: string,\n    articleSlug: string,\n    responses: ReflectionResponse[]\n): Promise<void> {\n    const user = auth.currentUser;\n    if (!user) return;\n\n    const journalId = `${user.uid}_${articleId}`;\n    const journalDoc = doc(db, 'reflectionJournals', journalId);\n\n    const journalEntry: ReflectionJournalEntry = {\n        userId: user.uid,\n        articleId,\n        articleTitle,\n        articleSlug,\n        responses,\n        createdAt: serverTimestamp() as Timestamp,\n        updatedAt: serverTimestamp() as Timestamp\n    };\n\n    try {\n        await setDoc(journalDoc, journalEntry);\n    } catch (error) {\n        console.error('Error creating reflection journal:', error);\n    }\n}\n\n// Get user's reflection journals - build from individual responses\nexport async function getUserReflectionJournals(userId?: string): Promise<ReflectionJournalEntry[]> {\n    const user = auth.currentUser;\n    const targetUserId = userId || user?.uid;\n\n    // Get all reflection responses and build journal entries from them\n    const journalMap = new Map<string, ReflectionJournalEntry>();\n\n    // Get from Firestore if user is authenticated\n    if (user && targetUserId) {\n        try {\n            const reflectionRef = collection(db, 'reflectionResponses');\n            const q = query(\n                reflectionRef,\n                where('userId', '==', targetUserId),\n                orderBy('createdAt', 'desc')\n            );\n\n            const querySnapshot = await getDocs(q);\n            querySnapshot.docs.forEach(doc => {\n                const response = doc.data() as ReflectionResponse;\n                const articleId = response.articleId;\n\n                if (!journalMap.has(articleId)) {\n                    journalMap.set(articleId, {\n                        userId: response.userId,\n                        articleId: articleId,\n                        articleTitle: `Loading...`, // Will be updated with actual title\n                        articleSlug: articleId,\n                        responses: [],\n                        createdAt: response.createdAt,\n                        updatedAt: response.createdAt\n                    });\n                }\n\n                const journal = journalMap.get(articleId)!;\n                journal.responses.push(response);\n                // Update the updated time to the latest response\n                if (response.createdAt > journal.updatedAt) {\n                    journal.updatedAt = response.createdAt;\n                }\n            });\n        } catch (error) {\n            console.error('Error fetching reflection responses from Firestore:', error);\n        }\n    }\n\n    // Also get from local storage\n    try {\n        const localStorageKeys = Object.keys(localStorage).filter(key => key.startsWith('reflection_'));\n\n        localStorageKeys.forEach(key => {\n            const articleId = key.replace('reflection_', '');\n            const data = localStorage.getItem(key);\n            if (!data) return;\n\n            try {\n                const reflections = JSON.parse(data);\n                if (!Array.isArray(reflections)) return;\n\n                reflections.forEach((reflection: any) => {\n                    const response: ReflectionResponse = {\n                        id: reflection.id || `local_${Date.now()}`,\n                        userId: 'local',\n                        articleId: articleId,\n                        promptId: reflection.promptId,\n                        promptText: reflection.promptText,\n                        response: reflection.response,\n                        position: reflection.position,\n                        createdAt: new Date(reflection.createdAt) as any,\n                        isPrivate: reflection.isPrivate\n                    };\n\n                    if (!journalMap.has(articleId)) {\n                        journalMap.set(articleId, {\n                            userId: 'local',\n                            articleId: articleId,\n                            articleTitle: `Loading...`, // Will be updated with actual title\n                            articleSlug: articleId,\n                            responses: [],\n                            createdAt: response.createdAt,\n                            updatedAt: response.createdAt\n                        });\n                    }\n\n                    const journal = journalMap.get(articleId)!;\n                    // Check if this response already exists (avoid duplicates)\n                    const exists = journal.responses.some(r =>\n                        r.promptId === response.promptId &&\n                        r.position === response.position &&\n                        r.response === response.response\n                    );\n\n                    if (!exists) {\n                        journal.responses.push(response);\n                        if (response.createdAt > journal.updatedAt) {\n                            journal.updatedAt = response.createdAt;\n                        }\n                    }\n                });\n            } catch (error) {\n                console.error('Error parsing local storage reflection data:', error);\n            }\n        });\n    } catch (error) {\n        console.error('Error reading from local storage:', error);\n    }\n\n    // Convert map to array and fetch article titles\n    const journals = Array.from(journalMap.values()).filter(journal => journal.responses.length > 0);\n\n    // Fetch article metadata for each journal using Firebase document ID\n    await Promise.all(journals.map(async (journal) => {\n        try {\n            // Use Firebase getArticleById since the articleId is a Firebase document ID\n            const { getArticleById } = await import('@/firebase/articles');\n            const firebaseArticle = await getArticleById(journal.articleId);\n\n            if (firebaseArticle) {\n                journal.articleTitle = firebaseArticle.title;\n                journal.articleSlug = firebaseArticle.slug || journal.articleId; // Update slug if available\n                console.log(`Successfully fetched title for ${journal.articleId}: ${firebaseArticle.title}`);\n            } else {\n                journal.articleTitle = `Article: ${journal.articleId}`;\n                console.log(`Article not found for ID: ${journal.articleId}`);\n            }\n        } catch (error) {\n            console.error(`Error fetching article for ${journal.articleId}:`, error);\n            journal.articleTitle = `Article: ${journal.articleId}`;\n        }\n    }));\n\n    // Sort by updated time\n    journals.sort((a, b) => {\n        const timeA = a.updatedAt instanceof Date ? a.updatedAt.getTime() : a.updatedAt.toMillis();\n        const timeB = b.updatedAt instanceof Date ? b.updatedAt.getTime() : b.updatedAt.toMillis();\n        return timeB - timeA;\n    });\n\n    return journals;\n}\n\n// Delete a reflection response\nexport async function deleteReflectionResponse(\n    articleId: string,\n    reflectionId: string\n): Promise<boolean> {\n    console.log('Deleting reflection:', { articleId, reflectionId });\n\n    const user = auth.currentUser;\n    let deletedFromFirestore = false;\n    let deletedFromLocal = false;\n\n    // Delete from Firestore if user is authenticated\n    if (user) {\n        try {\n            // Try to find and delete from Firestore\n            const reflectionRef = collection(db, 'reflectionResponses');\n            const q = query(\n                reflectionRef,\n                where('userId', '==', user.uid),\n                where('articleId', '==', articleId),\n                where('id', '==', reflectionId)\n            );\n\n            const querySnapshot = await getDocs(q);\n            if (!querySnapshot.empty) {\n                const docToDelete = querySnapshot.docs[0];\n                await deleteDoc(docToDelete.ref);\n                console.log('Successfully deleted from Firestore');\n                deletedFromFirestore = true;\n            }\n        } catch (error) {\n            console.error('Error deleting from Firestore:', error);\n        }\n    }\n\n    // Delete from local storage\n    try {\n        const storageKey = `reflection_${articleId}`;\n        const existingData = localStorage.getItem(storageKey);\n\n        if (existingData) {\n            const reflections = JSON.parse(existingData);\n            const filteredReflections = reflections.filter((r: any) => r.id !== reflectionId);\n\n            if (filteredReflections.length !== reflections.length) {\n                if (filteredReflections.length === 0) {\n                    localStorage.removeItem(storageKey);\n                } else {\n                    localStorage.setItem(storageKey, JSON.stringify(filteredReflections));\n                }\n                console.log('Successfully deleted from local storage');\n                deletedFromLocal = true;\n            }\n        }\n    } catch (error) {\n        console.error('Error deleting from local storage:', error);\n    }\n\n    return deletedFromFirestore || deletedFromLocal;\n}\n\n// Get inspiration from user's reflections with metadata\nexport async function getReflectionInspiration(userId?: string): Promise<Array<{ response: string, articleTitle?: string, promptText?: string }>> {\n    const user = auth.currentUser;\n    const targetUserId = userId || user?.uid;\n\n    const inspirations: Array<{ response: string, articleTitle?: string, promptText?: string }> = [];\n    const seenResponses = new Set<string>();\n\n    // Get from Firestore if user is authenticated\n    if (user && targetUserId) {\n        try {\n            const reflectionRef = collection(db, 'reflectionResponses');\n            const q = query(\n                reflectionRef,\n                where('userId', '==', targetUserId),\n                orderBy('createdAt', 'desc'),\n                limit(10) // Get recent reflections\n            );\n\n            const querySnapshot = await getDocs(q);\n\n            // Create a map to get article titles\n            const articleTitleMap = new Map<string, string>();\n\n            for (const doc of querySnapshot.docs) {\n                const response = doc.data() as ReflectionResponse;\n                if (response.response && response.response.length > 20) {\n                    const normalizedResponse = response.response.toLowerCase().trim();\n                    if (!seenResponses.has(normalizedResponse)) {\n                        seenResponses.add(normalizedResponse);\n\n                        // Try to get article title if not cached\n                        let articleTitle = articleTitleMap.get(response.articleId);\n                        if (!articleTitle) {\n                            try {\n                                const { getArticleById } = await import('@/firebase/articles');\n                                const article = await getArticleById(response.articleId);\n                                articleTitle = article?.title || 'Unknown Article';\n                                articleTitleMap.set(response.articleId, articleTitle);\n                            } catch (error) {\n                                articleTitle = 'Unknown Article';\n                            }\n                        }\n\n                        inspirations.push({\n                            response: response.response,\n                            articleTitle: articleTitle,\n                            promptText: response.promptText\n                        });\n                    }\n                }\n            }\n        } catch (error) {\n            console.error('Error fetching inspiration from Firestore:', error);\n        }\n    }\n\n    // Also get from local storage\n    try {\n        const localStorageKeys = Object.keys(localStorage).filter(key => key.startsWith('reflection_'));\n        const localReflections: any[] = [];\n\n        localStorageKeys.forEach(key => {\n            const data = localStorage.getItem(key);\n            if (data) {\n                try {\n                    const reflections = JSON.parse(data);\n                    if (Array.isArray(reflections)) {\n                        localReflections.push(...reflections);\n                    }\n                } catch (error) {\n                    console.error('Error parsing local storage reflection:', error);\n                }\n            }\n        });\n\n        // Sort by creation date and take recent ones\n        localReflections\n            .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())\n            .slice(0, 10)\n            .forEach(reflection => {\n                if (reflection.response && reflection.response.length > 20) {\n                    const normalizedResponse = reflection.response.toLowerCase().trim();\n                    if (!seenResponses.has(normalizedResponse)) {\n                        seenResponses.add(normalizedResponse);\n                        inspirations.push({\n                            response: reflection.response,\n                            articleTitle: 'Local Article', // We could enhance this later\n                            promptText: reflection.promptText\n                        });\n                    }\n                }\n            });\n    } catch (error) {\n        console.error('Error reading inspiration from local storage:', error);\n    }\n\n    // Shuffle and return up to 5 inspirations\n    const shuffled = inspirations.sort(() => Math.random() - 0.5);\n    return shuffled.slice(0, 5);\n}\n\n// Get reflection themes/topics for inspiration\nexport async function getReflectionThemes(userId?: string): Promise<string[]> {\n    const user = auth.currentUser;\n    const targetUserId = userId || user?.uid;\n\n    const themes = new Set<string>();\n    const prompts: string[] = [];\n\n    // Get prompts from Firestore\n    if (user && targetUserId) {\n        try {\n            const reflectionRef = collection(db, 'reflectionResponses');\n            const q = query(\n                reflectionRef,\n                where('userId', '==', targetUserId),\n                orderBy('createdAt', 'desc'),\n                limit(20)\n            );\n\n            const querySnapshot = await getDocs(q);\n            querySnapshot.docs.forEach(doc => {\n                const response = doc.data() as ReflectionResponse;\n                if (response.promptText) {\n                    prompts.push(response.promptText);\n                }\n            });\n        } catch (error) {\n            console.error('Error fetching themes from Firestore:', error);\n        }\n    }\n\n    // Get from local storage\n    try {\n        const localStorageKeys = Object.keys(localStorage).filter(key => key.startsWith('reflection_'));\n\n        localStorageKeys.forEach(key => {\n            const data = localStorage.getItem(key);\n            if (data) {\n                try {\n                    const reflections = JSON.parse(data);\n                    if (Array.isArray(reflections)) {\n                        reflections.forEach((reflection: any) => {\n                            if (reflection.promptText) {\n                                prompts.push(reflection.promptText);\n                            }\n                        });\n                    }\n                } catch (error) {\n                    console.error('Error parsing local storage for themes:', error);\n                }\n            }\n        });\n    } catch (error) {\n        console.error('Error reading themes from local storage:', error);\n    }\n\n    // Extract themes from prompts\n    prompts.forEach(prompt => {\n        const lowerPrompt = prompt.toLowerCase();\n        if (lowerPrompt.includes('feel')) themes.add('emotions');\n        if (lowerPrompt.includes('choice') || lowerPrompt.includes('decision')) themes.add('decision-making');\n        if (lowerPrompt.includes('experience')) themes.add('personal experience');\n        if (lowerPrompt.includes('question')) themes.add('questioning');\n        if (lowerPrompt.includes('surprise')) themes.add('unexpected insights');\n        if (lowerPrompt.includes('perspective') || lowerPrompt.includes('view')) themes.add('perspectives');\n        if (lowerPrompt.includes('author')) themes.add('dialogue with authors');\n        if (lowerPrompt.includes('relate') || lowerPrompt.includes('connect')) themes.add('connections');\n    });\n\n    return Array.from(themes).slice(0, 6);\n}\n\n/**\n * Enable reflection room for an article (author only)\n */\nexport async function enableReflectionRoom(articleId: string, topic: string): Promise<void> {\n    const currentUser = auth.currentUser;\n    if (!currentUser) {\n        throw new Error('Authentication required');\n    }\n\n    try {\n        // Update article to enable reflection room\n        const articleRef = doc(db, 'articles', articleId);\n        await updateDoc(articleRef, {\n            hasReflectionRoom: true,\n            updatedAt: serverTimestamp()\n        });\n\n        // Create reflection room metadata\n        const metadataRef = doc(db, 'reflections', articleId, 'metadata', 'main');\n        await setDoc(metadataRef, {\n            topic: topic,\n            createdAt: serverTimestamp(),\n            authorId: currentUser.uid\n        });\n\n    } catch (error) {\n        console.error('Error enabling reflection room:', error);\n        throw error;\n    }\n}\n\n/**\n * Disable reflection room for an article (author only)\n */\nexport async function disableReflectionRoom(articleId: string): Promise<void> {\n    const currentUser = auth.currentUser;\n    if (!currentUser) {\n        throw new Error('Authentication required');\n    }\n\n    try {\n        // Update article to disable reflection room\n        const articleRef = doc(db, 'articles', articleId);\n        await updateDoc(articleRef, {\n            hasReflectionRoom: false,\n            updatedAt: serverTimestamp()\n        });\n\n    } catch (error) {\n        console.error('Error disabling reflection room:', error);\n        throw error;\n    }\n}\n\n/**\n * Update reflection room topic (author only)\n */\nexport async function updateReflectionTopic(articleId: string, newTopic: string): Promise<void> {\n    const currentUser = auth.currentUser;\n    if (!currentUser) {\n        throw new Error('Authentication required');\n    }\n\n    try {\n        const metadataRef = doc(db, 'reflections', articleId, 'metadata', 'main');\n        await updateDoc(metadataRef, {\n            topic: newTopic,\n            updatedAt: serverTimestamp()\n        });\n\n    } catch (error) {\n        console.error('Error updating reflection topic:', error);\n        throw error;\n    }\n} "],"names":[],"mappings":"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","debugId":null}}]
}