"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4744],{3201:(e,r,t)=>{t.d(r,{db:()=>l,j2:()=>c});var o=t(3915),a=t(6864),n=t(6597),i=t(5112);let s=(0,o.Wp)({apiKey:"AIzaSyCFpybhLt43iKUw6lNahU1n2zjYv0BXmf4",authDomain:"journalitev1.firebaseapp.com",projectId:"journalitev1",storageBucket:"journalitev1.firebasestorage.app",messagingSenderId:"897263211529",appId:"1:897263211529:web:bae4a00910a2236d6d54d8",measurementId:"G-ZYT8PRMT0D"});try{(0,a.P5)(s)}catch(e){}let c=(0,n.getAuth)(s),l=(0,i.getFirestore)(s);window.location.origin},4744:(e,r,t)=>{t.d(r,{Ay:()=>d,Ci:()=>b,E$:()=>m,OQ:()=>s,Qt:()=>h,SR:()=>g,VM:()=>l,Vz:()=>c,e_:()=>u,mH:()=>y,pV:()=>f,x5:()=>w});var o=t(5112),a=t(6597),n=t(3201),i=t(9995);async function s(e){try{let r=(0,o.query)((0,o.collection)(n.db,"users"),(0,o.where)("username","==",e.toLowerCase()));return!(await (0,o.getDocs)(r)).empty}catch(e){throw console.error("Error checking username:",e),e}}async function c(e,r){try{let t=await l(e);if(t){let i=(0,o.doc)(n.db,"users",e);await (0,o.updateDoc)(i,{firstName:r.firstName,lastName:r.lastName,username:r.username.toLowerCase(),email:r.email.toLowerCase(),bio:r.bio||t.bio||""}),n.j2.currentUser&&await (0,a.updateProfile)(n.j2.currentUser,{displayName:r.username});return}let i=(0,o.query)((0,o.collection)(n.db,"users"),(0,o.where)("email","==",r.email.toLowerCase()));if(!(await (0,o.getDocs)(i)).empty)throw Error("Email is already associated with another account");if(await s(r.username))throw Error("Username is already taken");let c=(0,o.doc)(n.db,"users",e);await (0,o.setDoc)(c,{uid:e,firstName:r.firstName,lastName:r.lastName,username:r.username.toLowerCase(),email:r.email.toLowerCase(),bio:r.bio||"",createdAt:(0,o.serverTimestamp)()}),n.j2.currentUser&&await (0,a.updateProfile)(n.j2.currentUser,{displayName:r.username})}catch(e){throw console.error("Error creating user profile:",e),e}}async function l(e){try{let r=(0,o.doc)(n.db,"users",e),t=await (0,o.getDoc)(r);if(t.exists())return t.data();return null}catch(e){throw console.error("Error fetching user profile:",e),e}}async function u(e){if(!e)return null;try{let r=(0,o.query)((0,o.collection)(n.db,"users"),(0,o.where)("email","==",e.toLowerCase()),(0,o.limit)(1)),t=await (0,o.getDocs)(r);if(!t.empty)return t.docs[0].data();return null}catch(e){throw console.error("Error fetching user profile by email:",e),e}}async function d(e,r){try{let t=(0,o.doc)(n.db,"users",e);await (0,o.updateDoc)(t,{interests:r})}catch(e){throw console.error("Error updating user interests:",e),e}}async function w(e){try{if(!e||e.trim().length<2)return[];let r=e.toLowerCase().trim(),t=(0,o.collection)(n.db,"users");return(await (0,o.getDocs)(t)).docs.map(e=>e.data()).filter(e=>{let t=e.username.toLowerCase(),o=e.firstName.toLowerCase(),a=e.lastName.toLowerCase(),n="".concat(o," ").concat(a);return t.includes(r)||o.includes(r)||a.includes(r)||n.includes(r)})}catch(e){return console.error("Error searching users:",e),[]}}async function f(e,r){try{if(e===r)throw Error("You cannot follow yourself");let t=(0,o.doc)(n.db,"users",e);await (0,o.updateDoc)(t,{following:(0,o.arrayUnion)(r),followingCount:(0,o.increment)(1)});let a=(0,o.doc)(n.db,"users",r);await (0,o.updateDoc)(a,{followers:(0,o.arrayUnion)(e),followersCount:(0,o.increment)(1)});let s=await (0,o.getDoc)(t);if(s.exists()){let t=s.data();await (0,i.N9)(r,"".concat(t.firstName," ").concat(t.lastName),e,t.username)}}catch(e){throw console.error("Error following user:",e),e}}async function h(e,r){try{let t=(0,o.doc)(n.db,"users",e);await (0,o.updateDoc)(t,{following:(0,o.arrayRemove)(r),followingCount:(0,o.increment)(-1)});let a=(0,o.doc)(n.db,"users",r);await (0,o.updateDoc)(a,{followers:(0,o.arrayRemove)(e),followersCount:(0,o.increment)(-1)})}catch(e){throw console.error("Error unfollowing user:",e),e}}async function m(e,r){try{var t;let a=(0,o.doc)(n.db,"users",e),i=await (0,o.getDoc)(a);if(!i.exists())return!1;return(null==(t=i.data().following)?void 0:t.includes(r))||!1}catch(e){throw console.error("Error checking follow status:",e),e}}async function y(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:50;try{let t=(0,o.doc)(n.db,"users",e),a=await (0,o.getDoc)(t);if(!a.exists())return[];let i=a.data().following||[];if(0===i.length)return[];let s=[],c=Math.min(i.length,r);for(let e=0;e<c;e++){let r=i[e],t=(0,o.doc)(n.db,"users",r),a=await (0,o.getDoc)(t);a.exists()&&s.push(a.data())}return s}catch(e){throw console.error("Error getting following list:",e),e}}async function g(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:50;try{let t=(0,o.doc)(n.db,"users",e),a=await (0,o.getDoc)(t);if(!a.exists())return[];let i=a.data().followers||[];if(0===i.length)return[];let s=[],c=Math.min(i.length,r);for(let e=0;e<c;e++){let r=i[e],t=(0,o.doc)(n.db,"users",r),a=await (0,o.getDoc)(t);a.exists()&&s.push(a.data())}return s}catch(e){throw console.error("Error getting followers list:",e),e}}async function b(e){try{let r=(0,o.doc)(n.db,"users",e);await (0,o.deleteDoc)(r);let t=n.j2.currentUser;if(t&&t.uid===e)await (0,a.deleteUser)(t);else if(t)throw console.error("Current authenticated user does not match UID to be deleted."),Error("Mismatch between authenticated user and account to be deleted.");else throw console.error("No current user authenticated. Cannot delete Firebase Auth user."),Error("Authentication required to delete account.")}catch(e){if(console.error("Error deleting user account:",e),"auth/requires-recent-login"===e.code)throw Error("This operation is sensitive and requires recent authentication. Please sign out and sign back in, then try again.");throw Error("Failed to delete user account. "+e.message)}}},9995:(e,r,t)=>{t.d(r,{Hs:()=>u,N9:()=>n,Ss:()=>i,bA:()=>s,fP:()=>l,he:()=>c});var o=t(5112),a=t(3201);async function n(e,r,t,n){try{if(e===t)return null;let i={userId:e,type:"follow",read:!1,sourceId:t,sourceType:"user",message:"".concat(r," (@").concat(n,") started following you"),fromUser:{id:t,name:r,username:n},createdAt:o.Timestamp.now()};return{id:(await (0,o.addDoc)((0,o.collection)(a.db,"notifications"),i)).id,...i}}catch(e){return console.error("Error creating follow notification:",e),null}}async function i(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];try{let r,t=a.j2.currentUser;if(!t)throw Error("User not authenticated");let n=(0,o.collection)(a.db,"notifications");r=e?(0,o.query)(n,(0,o.where)("userId","==",t.uid),(0,o.where)("read","==",!1),(0,o.orderBy)("createdAt","desc"),(0,o.limit)(100)):(0,o.query)(n,(0,o.where)("userId","==",t.uid),(0,o.orderBy)("createdAt","desc"),(0,o.limit)(100));let i=await (0,o.getDocs)(r),s=[];return i.forEach(e=>{s.push({id:e.id,...e.data()})}),s}catch(e){throw console.error("Error fetching notifications:",e),e}}async function s(e){try{let r=a.j2.currentUser;if(!r)throw Error("User not authenticated");let t=(0,o.doc)(a.db,"notifications",e),n=await (0,o.getDoc)(t);if(!n.exists())throw Error("Notification not found");if(n.data().userId!==r.uid)throw Error("Unauthorized access to notification");return await (0,o.updateDoc)(t,{read:!0}),{success:!0}}catch(e){throw console.error("Error marking notification as read:",e),e}}async function c(){try{let e=a.j2.currentUser;if(!e)throw Error("User not authenticated");let r=(0,o.collection)(a.db,"notifications"),t=(0,o.query)(r,(0,o.where)("userId","==",e.uid),(0,o.where)("read","==",!1)),n=await (0,o.getDocs)(t),i=n.docs.map(e=>(0,o.updateDoc)(e.ref,{read:!0}));return await Promise.all(i),{success:!0,count:n.size}}catch(e){throw console.error("Error marking all notifications as read:",e),e}}async function l(e){try{let r=a.j2.currentUser;if(!r)throw Error("User not authenticated");let t=(0,o.doc)(a.db,"notifications",e),n=await (0,o.getDoc)(t);if(!n.exists())throw Error("Notification not found");if(n.data().userId!==r.uid)throw Error("Unauthorized access to notification");return await (0,o.deleteDoc)(t),{success:!0}}catch(e){throw console.error("Error deleting notification:",e),e}}async function u(){try{let e=a.j2.currentUser;if(!e)return 0;let r=(0,o.collection)(a.db,"notifications"),t=(0,o.query)(r,(0,o.where)("userId","==",e.uid),(0,o.where)("read","==",!1));return(await (0,o.getDocs)(t)).size}catch(e){return console.error("Error counting unread notifications:",e),0}}}}]);